#+TAGS: algebra(a) discrete(d) systems(u) comporg(c) notes(n) homework(w) exam(e) definition proof theorem
* Projects  
  This file is for all things that require multiple steps to complete.
** School
*** Classes
**** Abstract Algebra (Psyche 206)                                  :algebra:
     <2019-01-09 Wed 11:00-11:50 +1w>
     <2019-01-11 Fri 11:00-11:50 +1w>
     <2019-01-14 Mon 11:00-11:50 +1w>
***** Notes                                                           :notes:
****** Lecture 1
       [2019-01-09 Wed]
******* Homeworks or quizes on friday.
	Alternated randomly. Always get a homework sheet regardless.
	Buffer: 100 * (Total Points earned) / (Total Possible points) * 0.9
	Only selected problems will be graded. Participation points for ungraded attempted problems.
******* Office hour Mon 3, Wed 1 (Math 220), Thu 10  
******* 100 hw/quizzes, 100 midterms, 100 final
******* Rings (or how I learned to love the polynomial)
******** Def: A ring is a triple (R, +, *) where R is a set and +, *: R \times R \to R are two binary ops st :definition:
********* (R, +) is an abelian group with identity O_r=O\in R 
********* For all a,b,c \in R
********** a*(b*c)=(a*b)*c
********** a*(b+c) = a*b+a*c and (a+b)*c=a*c+b*c
********* (R,*) is not necessarily a group. It does not necessarily have invereses
********* We say R is unital if R has a multiplicative id 1_r=1\in R. In a unital ring not every element has a multiplicative inverse.
********* If n\gt0 an integer then na = a+a+a+...+a and a^n = a*a*...a
********* In general ab \ne ba for all a,b\in R. If ab = ba for all a,b \in R then R is commutative. 
********* Examples
********** Integers, Rationals, Reals, Complex are all commutative unital rings under usual defs
********** For n\gt0 an int the set nZ={xn | x\in Z} is also a ring. 
********** If n\gt1 then nZ is not unital because the id is not there.
********** Assume R is a ring and n\to is an int. Let I={1,...n}. Let M_n(R)={a:I cross I \to R}. M_n(R) is a ring with the ops
*********** (a+b)(i,j) = a(i,j) + b(i,j) 
*********** (ab)(i,j) = \sum_k_\in_I a(i,k)b(k,j) 
*********** (M_r(R), +) is abelian group with id O_M_n_(R)(i,j)=O_r
*********** For any a,b,c\in M_n(R) and i,j\in I we have (a(bc))(i,j)=\sum a(i,k)((bc)(k,j))  
	                                                        =\sum\sum a(i,k)(b(k,l)c(l,j))
	                                                        =\sum\sum(a(i,k)b(k,l))c(l,j)
								=\sum((ab)(i,l))c(l,j)
								=((ab)c)(i,j)
********** If n\gt1 then M_n(R) is a non-commutative ring. If R is unital then M_n(R) is also unital.
********** For n\gt0 an int the set Z/nZ, which is a factor group under +, is also a ring. The multiplication is defined by (a + nZ)(b+nZ)=ab +nZ.
********** This is well-defined and makes Z/nZ into a ring. This is an example of a quotient ring
********** Every element has a multiplicative inverse iff n is prime.
********** Lemma(Rules of multiplication)                           :theorem:
	   Assume R is a ring. For any a,b,c\in R the following holds 
*********** a0=0=0a 
*********** a(-b)=(-a)b=-ab
*********** (-a)(-b)=ab
*********** a(b-c)=ab-ac and (b-c)a=ba-ca
	    Moreover if R is unital then
*********** (-1)a=-a
*********** (-1)(-1)=1
****** Lecture 2
       [2019-01-11 Fri]
******* Lemma (Multiplication)                              :theorem:
******** a0 = 0 = 0a \forall a \in R
******** (-a)b=a(-b)=-ab \forall a,n \in R
******* Proof                                                         :proof:
******** a0 + 0 = a0 = a(0 + 0) = a0 + a0 \to 0 = a0 
******** a(-b) ab = a(-b + b) = a0 = 0 \to a(-b) = -ab. A symmetric arg gives (-a)b=-ab
******* Example 
	Let R be a ring and fix X then let R[X] be the set of polynomials 
	\sum_i_\in_N_0 a_i X^i, N_0={0,1,2...} where a_i \in R and only finitely many a_i are non-zero.
	This is a ring under: 
	(\sum_i_\in_N_0 a^i x^i) + (\sum_i_\in_N_0 b^i x^i) = (\sum_i_\in_N_0 (a^i + b^i)x^i))
	(\sum_i_\in_N_0 a^i x^i) (\sum_i_\in_N_0 b^i x^i) = \sum_i_\in_N_0(\sum_k=0 a_k b_j_-k) x^i \forall \sum_i\inN_o a_i x^i, \sum_i\inN_o b_i x^i \in R[X]
******* Definition
******** If (R,+,*) is a ring then a subset S of R is a subring if (S,+,*) is a ring :definition:
******* Subring Test                                                :theorem:
******** If R is a ring and S \subset R a nonempty subset then S is a subring if a-b\inS and ab\in S \forall a,b\in S
******** Proof                                                        :proof:
	 By the one step subgroup test we have (S,+) is a subgroup of (R,+). As the semigroup and distributing
	 properties hold for all elements of R they must hold for all elements of S. The assumption ab\in S implies
	 * is a binary operation on S.
******* Example of subrings
******** For any integer n\gt0 we have nZ \subset Z is a subring 
******** The gaussian integers Z[i] = {a+bi | a,b\in Z} are a subring of C
******* Units
******** Def: If R is a unital ring then an element a \in R is called a unit if there exsists an element b \in R such that ab=1=ba. :definition:
       As for groups we have b is uniquely determined by a and we denote it by a^-1.
       The set U(R) of all units is a group under the multiplication on R.
******* Examples of Units
******** If R = M_2(Z) then U(R) = GL_2(Z). In general U(M_n(Z)) = GL_n(Z). 
******** If R = Z then U(R) = {1, -1}.
******** If n \gt 0 then U(Z/nZ) = U(n)
******* Integral Domains
******** In Z if ab = 0 then either a = 0 or b = 0 
******** Let R = M_2(Z) and let a = [0 1; 0 0] and b = [1 0; 0 0] then ab = [0 0; 0 0] and ba = [0 1; 0 0]
******** If R is a ring the a non-zero element a \in R is called a zero divisor if ab = 0 for some non-zero b \in R :definition:
******** A ring R is called an Integral Domain if R is commutative and has no zero divisor :definition:
******** In an Integral Domain we have ab = 0 \to a = 0 or b = 0
******* Examples of Integral Domains
******** Z is an Integral Domain. 
******** If p \gt 0 is a prime then Z/pZ is an Integral Domain.  
	 Assume a,b \in Z such that
	 (a + pZ)(b + pZ) = ab + pZ = pZ
	 then ab \in pZ so p divides ab.
	 As p is a prime either p | a or p |b so either a \in pZ or b \in pZ so either
	 a + pZ = pZ or b + pZ = pZ.
******** If n \gt 0 is non-prime then Z/nZ has zero divisors. 
	 If n = 8 then
	 (2 + 8Z)(4 + 8Z) = 8 + 8Z = 8Z 
******* Lemma: If R is an Integral Domain then for any a,b,c \in R with a \ne 0 we have ab = ac \to b = c. :theorem:
******* Proof                                                         :proof:
	ab = ac this implies a(b-c) = 0 so b-c = 0 because a \ne 0 which gives b = c.
****** Lecture 3
       [2019-01-14 Mon]
******* Last Time: Integral Domains. A commutative unital ring with no zero divisors.  
******* Remark: We say a is a left zero divisor if there exists a b\in R such that ab=0. resp. ba=0.
******* Remark: It is a two-sided zero divisor if it is both a left and right zero divisor.
******* In a commutative ring we have left divisor \to right divisor \to two-sided divisor.
******* Def: A field is a unital commutative ring in which every non-zero element is a unit. :definition:
******* Equivalently a field is a ring (R,\plus,\times) in which both (R,\plus) and (R,\times) are abelian groups. :definition:
******* Example Q\sub R\sub C are fields.
******* Theorem: A finite Integral Domain is a field.               :theorem:
******* Proof: Assume R is a finite Integral Domain.                  :proof:
	Let a\in R be a non-zero element then we claim there exists an integer k\gt=1 such that a^k=1.
	If this holds then aa^(k-1)=1=a^(k-1)a=a^-1.
	If a=1 the claim is clearly true so assume a\ne1.
	Consider the list a, a^2 ,a^3,... then as R is finite we must have a^i=a^j for some i \lt j.
	Hence a^j = a^i a^(j-i). Since this is an Integral Domain we have a^(j-i) = 1.
	Hence we can take k = j-i.
******* Corollary: For any prime p \gt 0 we have Z_p is a field.       :theorem:
******* Remark: For any prime power q = p^a, there exists a unique field k with |k|=q. The field is not Z/qZ. 
******* Example: Let Q[\radic2] = {a + b\radic2 | a,b \in Q}
	Then Q[\radic2] \sub R is a field.
	We know that (a+b\radic2)^-1 = \frac{1}{a+b\radic2}.
	Rationalize the denominator.
******* Characteristic of a ring
******** Def: Characteristic of a ring is defined as follows.    :definition:
	 Let n \gt 0 be the least positive integer such that nx=x+...+x=0 for all x \in R. 
	 If no such n exists then we say R has characteristic 0 and otherwise it has characteristic n. 
	 We denote by char(R) the characteristic.
******** Example: Z \sub Q \sub R \sub C have characteristic 0.
******** Example: Z_p has characteristic p\gt0
******** Example: char(M_n(R)) = char(R)
******** Example: char(R[x]) = char(R)
******** Lemma: If R is a unital ring then n = char(R) is the least positive integer such that n1 = 0, if it exists, or n = 0. :theorem:
******** Proof: For all x \in R we have nx = x + ...+x = 1x+...+1x=(1+...+1)x=(n1)x :proof:
	 If n1 = 0 then for all x \in R we have nx = (n1)x = 0x = 0.
******** Theorem: If R is an Integral Domain then either char(R) = 0 or char(R) = p a prime.:theorem:
******** Proof: Suppose n = char(R) \gt 0 and assume n = st with 1 \lt= s,t \lt= n :proof:
	 We have 0 = (1+...+1)n = (1+...+1)t+...(1+...+1)t)s = (1+...+1)s(1+...+1)t
	 As R is an Integral Domain either s1 = 0 or t1 = 0. 
	 If s1 = 0 then s = char(R) = n and likewise if t1 = 0. Hence n is a prime.
******** The characteristic has a big difference on the ring.
******** Lemma: If p \gt 0 is a prime then p | \binom{p}{i} for all 0 \lt i \lt p :theorem:
******** Proof: assume p \gt 0 is prime.                                :proof:
	 We have \binom{p}{i} = p!\i!(p-i)! so N\binom{p}{i} = p! where N = i!(p-1)!.
	 We must have p | N\binom{p}{i} so either p | N or p | \binom{p}{i}. 
	 By assumption N = a_1 ...a_k with a_i \lt p so we cannot have p | N.
	 Assume now that R is a commutative ring with char(R) = p \gt 0 a prime. By the binomial theorem for any a, b \in R then
	 (a + b)^p = \sum_u_=0 \binom{p}{i} a^i b^(p-1) = a^P + b^P. So npr = 0 for all n \ge 0, r \in R because if 0 \lt i \lt p then \binom{p}{i}a^i b^(p-i) = 0 
****** Lecture 4
       [2019-01-16 Wed]
******* Corollary: Assume R is an integral domain with characteristic p \gt 0 then if a \in R satisfies a^P = 1 then a = 1. :theorem:
******* Proof:                                                      :proof:
	By assumption we have a^P - 1 = 0.
	If p is odd then (-1)^P = -1.
	So a^P - 1 = a^P + (-1)^P = (a + (-1))^P = (a - 1)^P
	which implies a - 1 = 0 because R is an Integral Domain.
	If p = 2 the same argument works given that -1 = 1.
******* Compare this with the case R = C then we have p distinct elements a \in R such that a^P = 1. Thses are e^(2\pi i/p) with 0 \le i \le p.
******* Integral Domains are important when discussing solutions of polynomial equations.
******** x^2 - 4x + 3 = (x - 3)(x - 1) \in Z[x]
	 As Z is an Integral Domains we have either x - 3 = 0 or x - 1 =0 so either x = 3 or x =1.
	 Reducing mod 12 we get a polynomial x^2 - 4 x + 3. In Z_12 we have x = 7 and x = 9 are also solutions  of the polynomial.
******* Fields are bad.
	If R_1 ,...,R_k are rings then we can form an abelian group R \directsum ... R_k wunder addition. This can be made into a ring with
	multiplication componentwise. 
	It is unital, resp., commutative, iff all R_i are unital, resp., commutative
	If R_1 , R_2 are fields then R_1 \directsum R_2 is not a field. 
	If R_1 , R_2 are Integral Domains then R_1 \directsum R_2 is not an integral domain. 
	Pick a \in R_1 and b \in R_2 non-zero elements then (a,0)(0,b) = (a0,0b) = (0,0)
******* Ideals and Factor Rings
******** Let I \subset R be a subring of a ring R. We have I is a subgroup of the abelian R under addition.
	 As I is necessarily normal we can form the factor group R/I under addition. When does the multiplication in R 
	 give R/I a ring structure?
******** Def: A subring  I \sub R of a ring R is called a left, resp., right, ideal if for all r \in R and x \in I we have rx \in I, resp., xr \in I :definition:
******** We say I is a two-sided Ideal if it is both a left and right ideal.
******** Lemma: A non-empty subset I \sub R is an ideal if               :proof:
********* x - y \in I for all x,y \in I
********* rx \in I and xr \in I for all r \in R and x \in I
******** Example of Ideals
********* If R is a ring then {0} \sub R is an ideal.
********* For any integer n \ge 0, we have nZ \sub Z is an ideal.
********* Given x \in R we have the following principal ideals: 
********** Rx = {rx | r \in R} left ideal
********** xR = {xr | r \in R} right ideal
********** RxR = {rxs | r,s \in R} two-sided ideal
********** If R is commutative then Rx = xR = RxR and is sometimes denoted by <x>.
********* If R is a ring and f \in R[x] is a polynomial then set l(f) = min{i \in N_0 | a_i \ne 0}.
	  if n \ge 0 is an integer then I = {f \in R[x]} then l(f) \ge n is an ideal in R[x].
**** Discrete Algorithms (Gould-Simpson 906)                       :discrete:
     <2019-01-10 Thu 14:00-15:15 +1w>
     <2019-01-15 Tue 14:00-15:15 +1w>
     <2019-01-11 Fri 14:00-14:50 +1w>
***** Notes                                                           :notes:
****** Lecture 1 
       [2019-01-10 Thu]
******* Knights and Knaves 
******** Knights = always true, Knaves = always false, Normies = can lie or say the truth 
******** 3 People P M G one of each kind
********* P: At least one of us is a knave. 
********* M: *Says nothing*
********** If P = Knight \to statement is true \to M is a knave.
********** If P = Knave \to statement is false \to contradiction.
********** So P = Knight and M = Knave
********* P: Both of us are Knights
********* M: P is a Knight
********** If P = Knight \to Then both are Knights \to M = Knight  
********** If P = Knave \to P is false \to M is false \to M = Knave
********* P: G is the Knave
********* M: P is the Knight
********* G: I'm a normie
********** If P = Knight \to G is a knave \to G = Knave \to M = normie  
********** If P = Knave \to G is not a Knave \to G = normie \to M = Knight \to contradiction
********** If P = Normie \to G = knave \to M = Knight \to contradiction
****** Lecture 2
       [2019-01-15 Tue]
******* A type is a collection of values                         :definition:
******** Integers, Boolean etc.
******* A simple type is a type that can't be broken up into smaller types. :definition:
******* An aggregate type is a type that is not a simple type    :definition:
******* A data type is a type and operations on that type        :definition:
******* An abstract data type is the specification of a data type within some language independent of the implementation :definition:
******** Java interface. 
******* A data structure is the implementation of a data type    :definition:
******** A list is a sequence of data. A sequence implies there is an order.(index)
******** Lists are generally homogeneous
******** Things needed by a list
********* A create function
********* an insert function
********* Move cursor to location
********* an append function
********* a getValue function
********* A next and prev function
********* moveToStart and moveToEnd
********* a remove function
****** Lecture 3
       [2019-01-17 Thu]
******* Linked Lists
******** Composed of nodes
********* Nodes have a data value and a link to the next node in the list.
******** Maintain a head and tail pointer.
******** We need a current position pointer.
**** Systems Programming (Koffler 218)                              :systems:
     <2019-01-10 Thu 08:00-09:15 +1w>
     <2019-01-15 Tue 08:00-09:15 +1w>
***** Notes                                                           :notes:
****** Lecture 1 
       [2019-01-10 Thu]      
******* We just talked about syllabus stuff. 
****** Lecure 2
       [2019-01-15 Tue]
******* Operating System is a program that manages programs.   
******* Basic Bash stuff. You know this stuff already.
	#+BEGIN_SRC bash
	echo "Easy Stuff"
	#+END_SRC
******* Absolute File paths start at the root directory.
******* Relative path is how to get to a location from another location.
******* scp will transfer a file from one computer to another(lectura)
**** Computer Organization (Pacheco ILC 141)                        :comporg:
     <2019-01-10 Thu 12:30-13:45 +1w>
     <2019-01-15 Tue 12:30-13:45 +1w>
***** Notes                                                           :notes:
****** Lecture 1 
       [2019-01-10 Thu]
******* Just syllabus stuff 
****** Lecure 2
       [2019-01-15 Tue] 
******* There are a variety of number systems available. 
******* Computers use binary.
******* Binary is used because it is easy to represent with electrical signals.
******* A bit is a binary digit                                  :definition:
******* A byte is 8 bits                                         :definition:
******* A nibble is 4 bits                                       :definition:
******* LSB: Least significant Bit(Rightmost)                    :definition:
******* MSB: Most significant Bit(Leftmost)                      :definition:
******* Trinary was tried before and it was kind of cool but had a lot of technical problems.
******* A binary number is a polynomial with increasing power of two's
******* Max value in a byte: 2^8 - 1 = 255_ten
******* Binary Addition
******** Nothing special about binary addition. 
******** 00101010 + 00011111 = 01001001
******* Integers in computers are fixed size and can overflow.
****** Lecture 3
       [2019-01-17 Thu]
******* Carry-out vs. Overflow.
******** Carry-out is mechanical and expected. We lose the MSB but we don't care.
******** Overflow is an unexpected error.
******** 2-complement is both a format and a process.
*** Homework                                                       :homework:
**** HOMEWORK 345 Written assingment                               :discrete:
     DEADLINE: <2019-01-17 Thu 14:03>
**** HOMEWORK Zybooks reading.                                      :comporg: 
     DEADLINE: <2019-01-22 Tue 23:59 +7d>
     :PROPERTIES:
     :LAST_REPEAT: [2019-01-14 Mon 10:07]
     :END:
     - State "DONE"       from "HOMEWORK"   [2019-01-14 Mon 10:07]
**** HOMEWORK Sim project 1                                         :comporg: 
     DEADLINE: <2019-01-24 Thu 12:30>
**** HOMEWORK Assembly project 1                                    :comporg: 
     DEADLINE: <2019-01-31 Thu 12:30>
**** HOMEWORK Sim project 2                                         :comporg: 
     DEADLINE: <2019-02-07 Thu 17:16>
**** HOMEWORK Assembly project 2                                    :comporg: 
     DEADLINE: <2019-02-14 Thu 12:30>
**** HOMEWORK Simulation Project 3                                  :comporg: 
     DEADLINE: <2019-02-21 Thu 12:30>
**** HOMEWORK Assembly Project 3                                    :comporg: 
     DEADLINE: <2019-03-14 Thu 12:30>
**** HOMEWORK Simulation Project 4 Milestone 1                      :comporg: 
     DEADLINE: <2019-03-21 Thu 12:30>
**** HOMEWORK Assembly Project 4                                    :comporg:
     DEADLINE: <2019-04-04 Thu 12:30>
**** HOMEWORK Simulation Project 4 Milestone 2                      :comporg: 
     DEADLINE: <2019-03-28 Thu 12:30>
**** HOMEWORK Simulation Project 5                                  :comporg: 
     DEADLINE: <2019-04-11 Thu 12:30>
**** HOMEWORK Assembly Project 5                                    :comporg: 
     DEADLINE: <2019-04-18 Thu 12:30>
**** HOMEWORK Simulation Project 6                                  :comporg: 
     DEADLINE: <2019-04-25 Thu 12:30>
**** HOMEWORK Computer Organization Homework 1                      :comporg: 
     DEADLINE: <2019-01-29 Tue 17:00>
**** HOMEWORK Computer Organization Homework 2                      :comporg: 
     DEADLINE: <2019-02-12 Tue 17:00>
**** HOMEWORK Computer Organization Homework 3                      :comporg: 
     DEADLINE: <2019-03-12 Tue 17:00>
**** HOMEWORK Computer Organization Homework 4                      :comporg: 
     DEADLINE: <2019-03-26 Tue 17:00>
**** HOMEWORK Computer Organization Homework 5                      :comporg: 
     DEADLINE: <2019-04-09 Tue 17:00>
**** HOMEWORK Computer Organization Homework 6                      :comporg: 
     DEADLINE: <2019-04-23 Tue 17:00>
**** HOMEWORK Abstract Algebra Homework [25%]                       :algebra: 
     DEADLINE: <2019-01-18 Fri 11:00 +7d>
     1. [X] Problem 1
     2. [ ] Problem 2
     3. [ ] Problem 3
     4. [ ] Problem 4
**** HOMEWORK Systems Project 1                                     :systems: 
     DEADLINE: <2019-02-02 Sat 23:59>
**** HOMEWORK Systems Project 2                                     :systems: 
     DEADLINE: <2019-02-09 Sat 23:59>
**** HOMEWORK Systems Project 3                                     :systems: 
     DEADLINE: <2019-02-16 Sat 23:59>
**** HOMEWORK Systems Project 4                                     :systems: 
     DEADLINE: <2019-02-23 Sat 23:59>
**** HOMEWORK Systems Project 5                                     :systems: 
     DEADLINE: <2019-03-16 Sat 23:59>
**** HOMEWORK Systems Project 6                                     :systems: 
     DEADLINE: <2019-03-23 Sat 23:59>
**** HOMEWORK Systems Project 7                                     :systems: 
     DEADLINE: <2019-03-30 Sat 23:59>
**** HOMEWORK Systems Project 8                                     :systems: 
     DEADLINE: <2019-04-06 Sat 23:59>
**** HOMEWORK Systems Project 9                                     :systems: 
     DEADLINE: <2019-04-13 Sat 23:59>
**** HOMEWORK Systems Project 10                                    :systems: 
     DEADLINE: <2019-04-20 Sat 23:59>
**** HOMEWORK Systems Project 11                                    :systems: 
     DEADLINE: <2019-04-27 Sat 23:59>
*** Exams                                                              :exam:
**** EXAM Systems midterm                                           :systems:
     SCHEDULED: <2019-02-28 Thu 08:00>
**** EXAM Systems Final                                             :systems:
     SCHEDULED: <2019-05-09 Thu 08:00>
**** EXAM Computer Orginization final                               :comporg: 
     SCHEDULED: <2019-05-08 Wed 13:00-15:00>
**** EXAM Discrete final                                           :discrete: 
     SCHEDULED: <2019-05-06 Mon 15:30-17:30>
**** EXAM Discrete midterm 1                                       :discrete: 
     SCHEDULED: <2019-02-21 Thu 14:00>
**** EXAM Discrete midterm 2                                       :discrete: 
     SCHEDULED: <2019-04-11 Thu 14:00>
**** EXAM Computer Orginization Midterm 1                           :comporg: 
     SCHEDULED: <2019-01-31 Thu 12:30>
**** EXAM Computer Orginization Midterm 2                           :comporg: 
     SCHEDULED: <2019-02-14 Thu 12:30>
**** EXAM Computer Orginization Midterm 3                           :comporg: 
     SCHEDULED: <2019-03-14 Thu 12:30>
**** EXAM Computer Orginization Midterm 4                           :comporg: 
     SCHEDULED: <2019-03-28 Thu 12:30>
**** EXAM Computer Orginization Midterm 5                           :comporg: 
     SCHEDULED: <2019-04-11 Thu 12:30>
**** EXAM Computer Orginization Midterm 6                           :comporg:
     SCHEDULED: <2019-04-25 Thu 12:30>
**** EXAM Abstract Algebra Midterm 1                                :algebra: 
     SCHEDULED: <2019-02-27 Wed 11:00>
**** EXAM Abstract Algebra Midterm 2                                :algebra: 
     SCHEDULED: <2019-04-10 Wed 11:00>
